1.  State - это внутреннее состояние компонента, которое может быть изменено компонентом самим, либо его детьми. 
    Props - это аргументы, передаваемые в компонент из родительского компонента. 
    Основное отличие состоит в том, что состояние (state) изменяется внутри компонента, 
    в то время как свойства (props) передаются из вне. Кроме того, state может хранить значения, 
    которые могут изменяться в процессе работы компонента, в то время как props - это константы, 
    которые не изменяются внутри компонента.
2.  Исходный код:
    ```
    handleChange = () => {
        const chechedArr = this.state.arr; // [1,2,3] 
		chechedArr.push(5); // [1,2,3,5] 
        this.setState({
            arr: chechedArr,
        });
    };
    ```
    Ошибка в том, что мы изменяем состояние напрямую, а это недопустимо при использовании функции this.setState(). 
    Необходимо создать копию массива arr перед изменением его значения, чтобы не нарушить принципы иммутабельности данных. 

    Корректный код будет выглядеть так: 
    handleChange = () => {
        const checkedArr = [...this.state.arr];  // создаем копию массива
        checkedArr.push(5); // изменяем копию
        this.setState({
            arr: checkedArr, // обновляем состояние
        });
    };

3.  На один элемент можно повесить несколько обработчиков событий.

4.  Изменить state можно при помощи метода setState. 
    setState принимает в качестве аргумента новое значение для state и обновляет состояние компонента.
    Например:
    ```
    this.setState({
      checked: !this.state.checked,
    });
    ```

5.  Попробуйте предсказать какие сообщения будут в консоли и объяснить результат:
    ```
    handleChange = () => {
        console.log(this.state.checked) //#1 false 
        this.setState({
            checked: !this.state.checked, //true
        });
        console.log(this.state.checked) //#2 ?
    };
    ```
    #1 В консоли выведется значение false, которое находится в свойстве checked объекта state.
    #2 В консоли выведется значение false, которое находится в свойстве checked.
    Метод setState не успеет выполниться.
    * Однако следует учитывать, что метод setState работает асинхронно и зачастую не гарантирует мгновенного изменения this.state, 
    поэтому результат вывода в консоли может быть неожиданным. 
    Чтобы обеспечить корректный вывод, можно использовать функцию обратного вызова вторым аргументом метода setState 
    или использовать async/await функциональность.

6.  > Какими способами можно задать функцию handleChange и какой из них является самым правильным?
    1)  Создание метода внутри компонента:
    ```
    class MyInput extends React.Component {
        handleChange(event) {
            console.log(event.target.value);
        }

        render() {
            return (
                <input type="text" onChange={this.handleChange} />
            );
        }
    }
    ```
    2)  Использование стрелочной функции внутри атрибута onChange:
    ```
    class MyInput extends React.Component {
        render() {
            return (
                <input type="text" onChange={(event) => console.log(event.target.value)} />
            );
        }
    }
    ```
    3) Использование функции, объявленной снаружи компонента и передаваемой в него через props:
    ```
    function handleChange(event) {
        console.log(event.target.value);
    }

    class MyInput extends React.Component {
        render() {
            return (
                <input type="text" onChange={this.props.onChange} />
            );
        }
    }

    <MyInput onChange={handleChange} />
    ```
    Нет явного «правильного» способа, но наиболее удобный и распространенный способ - это создание метода внутри компонента. 
    Кроме того, использование стрелочных функций внутри атрибутов может привести к ненужным повторным рендерингам, 
    если они не привязаны к контексту, поэтому не стоит использовать этот способ в крупных приложениях.

7.  > Чем отличаются классовые и функциональные компоненты? Какие из них предпочтительнее в 2021 году?

    Классовые и функциональные компоненты отличаются способом их объявления и управления состоянием.
    В классовых компонентах есть свое состояние и уникальные жизненные циклы. Используется ключевое слово this.
    Функциональные компоненты возвращают React элементы. У них есть хуки.
    В 2021 году функциональные компоненты являются более предпочтительными, так как они более просты, 
    читаемы и могут использовать новые функциональности React, такие как хуки.

8.  > Есть ли this в функциональных компонентах? Как можно получить к нему доступ?
    Нет. Можно использовать хуки setState, useEffect, useContext для получения доступа к состоянию и контексту приложения.

9.  > Можно ли использовать props и state одновременно?
    Да.

10. > Где можно задать state без использования команды this.setState?

    State можно задать при создании компонента в конструкторе.  
    В конструкторе можно создать объект состояния и присвоить его переменной this.state. Например:

    ```
    class MyComponent extends React.Component {
        constructor(props) {
        super(props);
        this.state = { counter: 0 };
    }
    // остальной код компонента
    }
    ```

    ```
    class MyComponent extends React.Component {
        state = {
            status: false,
        };
        // остальной код компонента
    }
    ```
11. > Может ли состояние классового компонента не быть объектом? А функционального?

    Нет, в React состояние (state) классового и функционального компонента должно быть объектом. 

12. > Способны ли функциональные компоненты самостоятельно хранить состояние?

    Самостоятельно нет. Можно хранить состояние при помощи хуков(начиная с версии 16.8).

13. > Как использовать хуки в классовых компонентах?

    !! Никак
    !! https://react.dev/warnings/invalid-hook-call-warning

14. > А как задать начальное состояние props, если они еще не были переданы?

    Можно использовать значение по умолчанию в определении компонента. Например:

    ```
    class MyComponent extends React.Component {
        constructor(props) {
            super(props);
            this.state = {
                foo: this.props.foo || 'default value',
                bar: this.props.bar || 'default value',
        };
    }
    // ...
    }
    ```